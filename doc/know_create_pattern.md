<!--
 * @Descripttion: 
 * @version: 
 * @Author: danae
 * @Date: 2022-07-13 14:26:34
 * @LastEditors: danae
 * @LastEditTime: 2022-07-14 20:28:55
-->
# 知识点
完成比完美更重要

## 1.创建模式
### 1.1 单例模式
- [使用场景] 系统有多个资源，但只有一个资源管理器。例如公共配置类、资源类、日志类等

- [要点词语] static、=delete、=default、virtual、template、friend

- [异常问题] 并发引入加锁的性能影响，如何保障不能创建多实例

- [底层保障]  
    - C++11标准中的Magic Static特性：If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.
    如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。
    这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。

- [核心实现]
    - 将默认拷贝构造、赋值构造删除
    - 构造函数private
    - 唯一入口获取实例：实例为static运行期不释放，实例为引用不是指针，防止提前delete
    - 尽量不用锁，减少性能损耗
- [继承单例]
    - [核心实现]
        - 将子类作为模板传入，从而保证基类的getInstance( )入口可以初始化子类对象。注意这里和动态类调用的区别，由于子类构造私有，动态类仍只能获得基类对象，不是预期的子类对象；
        - 基类为友元类，因为基类GetInstance( )要调用子类的私有构造
        - 基类的构造由private，改为protected，因为子类的构造前会先调基类的构造
        - 基类的析构，改为virtual
    - [应用局限]
        - 一般用法，继承后子类不对外，只有父类对外且是单例
- [组合用法]
    - 例如：避免出现一堆单例，将所有资源例如数据库、HDFS连接等资源封装在一个单例类中
    - 例如：`日志类`作为抽象基类，通过构建`注册模板工厂`生产不同子类日志，从而实现配置文件中多个日志+新增子类继承日志基类，并通过`注册模板工厂`生产出日志子类对象。存在唯一单例系统日志，并且保证全局变量最晚释放，避免static全局函数使用已释放的日志指针

### 1.2 简单工厂（少用）
- [核心实现] 子类继承自统一父类，工厂由入参创建的对象
- [使用场景] 相同接口的产品类，继承统一抽象类，对使用者暴露工厂类，用于创建对象。使用者无需感知各子类名，只需传递名称字符串
- [设计弊端] 子类扩展，需要修改工厂，对现有代码有侵入性
  
![](../img/factory/simple.png)

### 1.3 工厂方法模式（常用）
- [核心实现] 工厂类只是抽象接口，每个子类对应一个工厂实现类。工厂实现类和子类个数是1：1
- [使用场景] 新增子类，无需修改已有工厂，对现有代码无侵入性（不修改只新增）
- [设计弊端] 每增加一个子类，对应增加一个工厂实现类，导致工厂类和产品类过多
  
![](../img/factory/method.png)

  
### 1.4 抽象工厂模式（少用）
![](../img/factory/abtract0.png)
- [核心实现] 将产品抽象类由1个，扩展为多个。不同工厂实现类创建N个产品实现类
- [设计弊端] 扩充产品抽象类的子类实现，需要对应增加工厂实现类
- [扩充例子] 下图是扩充后的例子

![](../img/factory/abtract1.png)

###$ 1.4.1 抽象模板工厂
- [核心实现] 对抽象工厂的升级，将工厂实现类抽象成模板，将产品抽象类和实现类作为模板参数传入
- [备注说明] 
  - 由于不同产品抽象类的构造入参不同，抽象模板类最后是可变参数，用于创建实际的产品类对象
  - 如果实现工厂模板有多个，也需要抽象工厂类，确保统一接口
 
![](../img/factory/abtract_template.png)

#### 1.4.2 抽象工厂注册工厂
- [核心实现] 对抽象工厂的再次升级，用于实现产品类注册，和按名称查找。增加注册产品模板类
- [备注说明] 也可直接调用ImplFactory的模板类Resigter()函数，原因？

![](../img/factory/abtract_resigter.png)

### 1.5 原型模式
- [核心实现] 通过将拷贝构造函数包装成子类可重载clone()虚函数，实现基类指针复制派生类的对象！节省CPU创建对象的时间
- [注意说明] 
    - 想要实现动态，一定要用指针创建类对象！
    - 拷贝构造函数要进行深拷贝
    - 克隆包含循环引用的复杂对象会非常麻烦？
- [使用场景] 
    - 克隆对象而不需与所属类相耦合
    - 克隆预先生成原型，避免反复运行初始化代码，创建大量对象，占用的CPU资源过多
    - 更方便生成复杂对象
- [拓展使用] 使用static提前创建实体类，https://www.runoob.com/design-pattern/prototype-pattern.html

### 1.6 建造者模式
- [核心实现]
    -将产品拆成几个组成部分创建。
    - 建造者抽象类将每部分的创建拆成接口，实现类可以有多种。
    - 组装者根据传入的建造者实例，支持多种多种顺序、或只选择部分生产出产品
- [注意说明] 
    - 建造者创建出产品如何销毁，避免内存泄露
- [使用场景]
    - 避免重叠构造函数，生成器模式可分步骤生成对象，不需要将几十个参数塞进构造函数里
    - 创造不同形式的产品，制造过程相似但有细节上的差异
    - 实用复杂的对象创建，例如组合树等。可延迟执行某些步骤或递归调用某些步骤

![](../img/factory/builder.png)