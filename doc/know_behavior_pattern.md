<!--
 * @Descripttion: 
 * @version: 
 * @Author: danae
 * @Date: 2022-07-20 17:30:06
 * @LastEditors: danae
 * @LastEditTime: 2022-07-22 17:54:56
-->
### 3.1 责任链
- [使用场景]
    - 程序需要使用不同方式处理不同种类请求，且请求类型和顺序未知时
    - 该模式形成一条链，收到请求后，会问询每个处理这，都有机会处理请求
    - 处理顺序必须在运行时改变，可以动态插入或移除处理者，改变其顺序
- [核心实现] 
    - 各处理者继承同一抽象类，且包含成员变量指向下一个处理者
    - 处理者接收到请求后做出2个决定，是否自行处理请求，是否将该请求沿着链传递
    - 客户端可以自行组织链，或者从其他对象获得预先组装好的链（实现工厂类根据配置或环境变量创建链）
    - 由于链的动态性，客户端请求可能：
        - 链中只有单个链接
        - 不能请求可能无法到链尾
        - 其他请求可能直到链尾都未被处理
- [区别]
    - **责任链**按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理
    - **命令**在发送者和请求者之间建立单向连接
    - **中介者**清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通
    - **观察者** 允许接收者动态地订阅或取消接收请求

![](../img/behavior/chain.png)


### 3.2 命令
- [整体说明]
   - `客户端`根据配置等将`命令`和`接收者`及命令的入参提前绑定。`触发器`在使用时直接调用命令，不必传参也不感知`接收者`。实现了触发器和接收者的解耦，更加灵活，且新增命令不必修改现有代码。
- [使用场景]
   - [命令和对象分离] CUI菜单，支持用户配置菜单项，并点击触发操作
   - [操作放入队列] 命令可序列号（转为字符串）存储。延迟初始化等
   - [回滚或重放] 命令历史记录包含所有执行命令和状态备份的栈机构，虽和备忘录结合，仍占用内存

- [核心实现]
    - **触发者invoker**: 不创建命令，只从客户端获得现有命令，并调命令执行
    - **命令command**: 声明一个 执行命令的方法，且无入参
    - **具体命令ImplCmd**: 实现各种类型的请求，委派给接受者执行。构造函数中指定Receiver和执行命令所需参数
    - **接收者Receiver**: 实际执行工作
    - **客户端client**: 创建具体的命令对象，将命令与Receiver关联，将invoker与多个command关联

- [注意区别]
   - **命令** 发送者和接收者建立单向连接
   - **中介者** 发送者和接收者通过中介对象间接沟通
   - **观察者** 允许接收者动态订阅取消接收请求

![](../img/behavior/cmd.png)

### 3.3 迭代器
- [整体说明]
    - 方法1: 通过已有的vector内存放模板实现
    - 方法2：迭代器包装自实现的循环逻辑，hasNext()等函数
- [使用场景]
    - **对客户端屏蔽内部复杂数据结构** 迭代器封装与复杂结构交互的细节，为客户端提供多个访问集合元素的简单方法
    - **减少程序中重复的遍历代码** 如果将复杂的迭代算法放在业务逻辑中，会让功能类的职责不清楚，降低维护性
    - **遍历不同的数据结构的通用模式** 通过将集合类传递给迭代器，实现通用的循环输出能力
- [核心实现]
    - **迭代器类**包含方法：获取下个元素、获取当前位置、判断迭代器是否结束
    - **集合类**创建迭代器对象，将自身类型作为模块参数传递，将自身对象作为参数传递给迭代器
    - **客户端**使用时，通过迭代器对象遍历集合全部元素

![](../img/behavior/iterator.png)


### 3.4 中介者
- [整体说明]
    - 通过中介者进行不同对象间交互，单一对象只引用中介者，而不用与其他对象耦合
- [使用场景]
    - **和其他对象解耦** 将对象间所有关系抽取一个单独类，使对于特定组件的修改独立于其他组件
    - **复用组件间合作关系** 无需修改组件，只提供一个新的中介者
- [核心实现]
    - **抽象中介者类** 一般只实现通知方法即可，如果要负责所有对象的创建和销毁，可与工厂结合
    - **组件(对象)类** 包含中介者的引用，在构造函数中传递进来
- [注意区别]
    - 用于处理请求发送者和接收者的不同连接方式
        - **责任链**按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理
        - **命令** 在发送者和请求者之间建立单向连接
        - **中介者** 清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通
        - **观察者**允许接收者动态地订阅或取消接收请求
    - 尝试在大量紧密耦合的类中组织起合作
        - **外观** 为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流
        - **中介者** 将系统中组件的沟通行为中心化。各组件只知道中介者对象， 无法直接相互交流
    - **中介者**和**观察者**之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 
        - 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。

        - 有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。

        - 当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。

        - 假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。

![](../img/behavior/mediator.png)